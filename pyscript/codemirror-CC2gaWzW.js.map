{"version":3,"file":"codemirror-CC2gaWzW.js","sources":["../node_modules/crelt/index.js","../node_modules/@codemirror/search/dist/index.js","../node_modules/@codemirror/lint/dist/index.js","../node_modules/codemirror/dist/index.js"],"sourcesContent":["export default function crelt() {\n  var elt = arguments[0]\n  if (typeof elt == \"string\") elt = document.createElement(elt)\n  var i = 1, next = arguments[1]\n  if (next && typeof next == \"object\" && next.nodeType == null && !Array.isArray(next)) {\n    for (var name in next) if (Object.prototype.hasOwnProperty.call(next, name)) {\n      var value = next[name]\n      if (typeof value == \"string\") elt.setAttribute(name, value)\n      else if (value != null) elt[name] = value\n    }\n    i++\n  }\n  for (; i < arguments.length; i++) add(elt, arguments[i])\n  return elt\n}\n\nfunction add(elt, child) {\n  if (typeof child == \"string\") {\n    elt.appendChild(document.createTextNode(child))\n  } else if (child == null) {\n  } else if (child.nodeType != null) {\n    elt.appendChild(child)\n  } else if (Array.isArray(child)) {\n    for (var i = 0; i < child.length; i++) add(elt, child[i])\n  } else {\n    throw new RangeError(\"Unsupported child node: \" + child)\n  }\n}\n","import { showPanel, EditorView, getPanel, Decoration, ViewPlugin, runScopeHandlers } from '@codemirror/view';\nimport { codePointAt, fromCodePoint, codePointSize, StateEffect, StateField, EditorSelection, Facet, combineConfig, CharCategory, RangeSetBuilder, Prec, EditorState, findClusterBreak } from '@codemirror/state';\nimport elt from 'crelt';\n\nconst basicNormalize = typeof String.prototype.normalize == \"function\"\n    ? x => x.normalize(\"NFKD\") : x => x;\n/**\nA search cursor provides an iterator over text matches in a\ndocument.\n*/\nclass SearchCursor {\n    /**\n    Create a text cursor. The query is the search string, `from` to\n    `to` provides the region to search.\n    \n    When `normalize` is given, it will be called, on both the query\n    string and the content it is matched against, before comparing.\n    You can, for example, create a case-insensitive search by\n    passing `s => s.toLowerCase()`.\n    \n    Text is always normalized with\n    [`.normalize(\"NFKD\")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)\n    (when supported).\n    */\n    constructor(text, query, from = 0, to = text.length, normalize, test) {\n        this.test = test;\n        /**\n        The current match (only holds a meaningful value after\n        [`next`](https://codemirror.net/6/docs/ref/#search.SearchCursor.next) has been called and when\n        `done` is false).\n        */\n        this.value = { from: 0, to: 0 };\n        /**\n        Whether the end of the iterated region has been reached.\n        */\n        this.done = false;\n        this.matches = [];\n        this.buffer = \"\";\n        this.bufferPos = 0;\n        this.iter = text.iterRange(from, to);\n        this.bufferStart = from;\n        this.normalize = normalize ? x => normalize(basicNormalize(x)) : basicNormalize;\n        this.query = this.normalize(query);\n    }\n    peek() {\n        if (this.bufferPos == this.buffer.length) {\n            this.bufferStart += this.buffer.length;\n            this.iter.next();\n            if (this.iter.done)\n                return -1;\n            this.bufferPos = 0;\n            this.buffer = this.iter.value;\n        }\n        return codePointAt(this.buffer, this.bufferPos);\n    }\n    /**\n    Look for the next match. Updates the iterator's\n    [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and\n    [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called\n    at least once before using the cursor.\n    */\n    next() {\n        while (this.matches.length)\n            this.matches.pop();\n        return this.nextOverlapping();\n    }\n    /**\n    The `next` method will ignore matches that partially overlap a\n    previous match. This method behaves like `next`, but includes\n    such matches.\n    */\n    nextOverlapping() {\n        for (;;) {\n            let next = this.peek();\n            if (next < 0) {\n                this.done = true;\n                return this;\n            }\n            let str = fromCodePoint(next), start = this.bufferStart + this.bufferPos;\n            this.bufferPos += codePointSize(next);\n            let norm = this.normalize(str);\n            if (norm.length)\n                for (let i = 0, pos = start;; i++) {\n                    let code = norm.charCodeAt(i);\n                    let match = this.match(code, pos, this.bufferPos + this.bufferStart);\n                    if (i == norm.length - 1) {\n                        if (match) {\n                            this.value = match;\n                            return this;\n                        }\n                        break;\n                    }\n                    if (pos == start && i < str.length && str.charCodeAt(i) == code)\n                        pos++;\n                }\n        }\n    }\n    match(code, pos, end) {\n        let match = null;\n        for (let i = 0; i < this.matches.length; i += 2) {\n            let index = this.matches[i], keep = false;\n            if (this.query.charCodeAt(index) == code) {\n                if (index == this.query.length - 1) {\n                    match = { from: this.matches[i + 1], to: end };\n                }\n                else {\n                    this.matches[i]++;\n                    keep = true;\n                }\n            }\n            if (!keep) {\n                this.matches.splice(i, 2);\n                i -= 2;\n            }\n        }\n        if (this.query.charCodeAt(0) == code) {\n            if (this.query.length == 1)\n                match = { from: pos, to: end };\n            else\n                this.matches.push(1, pos);\n        }\n        if (match && this.test && !this.test(match.from, match.to, this.buffer, this.bufferStart))\n            match = null;\n        return match;\n    }\n}\nif (typeof Symbol != \"undefined\")\n    SearchCursor.prototype[Symbol.iterator] = function () { return this; };\n\nconst empty = { from: -1, to: -1, match: /*@__PURE__*//.*/.exec(\"\") };\nconst baseFlags = \"gm\" + (/x/.unicode == null ? \"\" : \"u\");\n/**\nThis class is similar to [`SearchCursor`](https://codemirror.net/6/docs/ref/#search.SearchCursor)\nbut searches for a regular expression pattern instead of a plain\nstring.\n*/\nclass RegExpCursor {\n    /**\n    Create a cursor that will search the given range in the given\n    document. `query` should be the raw pattern (as you'd pass it to\n    `new RegExp`).\n    */\n    constructor(text, query, options, from = 0, to = text.length) {\n        this.text = text;\n        this.to = to;\n        this.curLine = \"\";\n        /**\n        Set to `true` when the cursor has reached the end of the search\n        range.\n        */\n        this.done = false;\n        /**\n        Will contain an object with the extent of the match and the\n        match object when [`next`](https://codemirror.net/6/docs/ref/#search.RegExpCursor.next)\n        sucessfully finds a match.\n        */\n        this.value = empty;\n        if (/\\\\[sWDnr]|\\n|\\r|\\[\\^/.test(query))\n            return new MultilineRegExpCursor(text, query, options, from, to);\n        this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? \"i\" : \"\"));\n        this.test = options === null || options === void 0 ? void 0 : options.test;\n        this.iter = text.iter();\n        let startLine = text.lineAt(from);\n        this.curLineStart = startLine.from;\n        this.matchPos = toCharEnd(text, from);\n        this.getLine(this.curLineStart);\n    }\n    getLine(skip) {\n        this.iter.next(skip);\n        if (this.iter.lineBreak) {\n            this.curLine = \"\";\n        }\n        else {\n            this.curLine = this.iter.value;\n            if (this.curLineStart + this.curLine.length > this.to)\n                this.curLine = this.curLine.slice(0, this.to - this.curLineStart);\n            this.iter.next();\n        }\n    }\n    nextLine() {\n        this.curLineStart = this.curLineStart + this.curLine.length + 1;\n        if (this.curLineStart > this.to)\n            this.curLine = \"\";\n        else\n            this.getLine(0);\n    }\n    /**\n    Move to the next match, if there is one.\n    */\n    next() {\n        for (let off = this.matchPos - this.curLineStart;;) {\n            this.re.lastIndex = off;\n            let match = this.matchPos <= this.to && this.re.exec(this.curLine);\n            if (match) {\n                let from = this.curLineStart + match.index, to = from + match[0].length;\n                this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));\n                if (from == this.curLineStart + this.curLine.length)\n                    this.nextLine();\n                if ((from < to || from > this.value.to) && (!this.test || this.test(from, to, match))) {\n                    this.value = { from, to, match };\n                    return this;\n                }\n                off = this.matchPos - this.curLineStart;\n            }\n            else if (this.curLineStart + this.curLine.length < this.to) {\n                this.nextLine();\n                off = 0;\n            }\n            else {\n                this.done = true;\n                return this;\n            }\n        }\n    }\n}\nconst flattened = /*@__PURE__*/new WeakMap();\n// Reusable (partially) flattened document strings\nclass FlattenedDoc {\n    constructor(from, text) {\n        this.from = from;\n        this.text = text;\n    }\n    get to() { return this.from + this.text.length; }\n    static get(doc, from, to) {\n        let cached = flattened.get(doc);\n        if (!cached || cached.from >= to || cached.to <= from) {\n            let flat = new FlattenedDoc(from, doc.sliceString(from, to));\n            flattened.set(doc, flat);\n            return flat;\n        }\n        if (cached.from == from && cached.to == to)\n            return cached;\n        let { text, from: cachedFrom } = cached;\n        if (cachedFrom > from) {\n            text = doc.sliceString(from, cachedFrom) + text;\n            cachedFrom = from;\n        }\n        if (cached.to < to)\n            text += doc.sliceString(cached.to, to);\n        flattened.set(doc, new FlattenedDoc(cachedFrom, text));\n        return new FlattenedDoc(from, text.slice(from - cachedFrom, to - cachedFrom));\n    }\n}\nclass MultilineRegExpCursor {\n    constructor(text, query, options, from, to) {\n        this.text = text;\n        this.to = to;\n        this.done = false;\n        this.value = empty;\n        this.matchPos = toCharEnd(text, from);\n        this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? \"i\" : \"\"));\n        this.test = options === null || options === void 0 ? void 0 : options.test;\n        this.flat = FlattenedDoc.get(text, from, this.chunkEnd(from + 5000 /* Chunk.Base */));\n    }\n    chunkEnd(pos) {\n        return pos >= this.to ? this.to : this.text.lineAt(pos).to;\n    }\n    next() {\n        for (;;) {\n            let off = this.re.lastIndex = this.matchPos - this.flat.from;\n            let match = this.re.exec(this.flat.text);\n            // Skip empty matches directly after the last match\n            if (match && !match[0] && match.index == off) {\n                this.re.lastIndex = off + 1;\n                match = this.re.exec(this.flat.text);\n            }\n            if (match) {\n                let from = this.flat.from + match.index, to = from + match[0].length;\n                // If a match goes almost to the end of a noncomplete chunk, try\n                // again, since it'll likely be able to match more\n                if ((this.flat.to >= this.to || match.index + match[0].length <= this.flat.text.length - 10) &&\n                    (!this.test || this.test(from, to, match))) {\n                    this.value = { from, to, match };\n                    this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));\n                    return this;\n                }\n            }\n            if (this.flat.to == this.to) {\n                this.done = true;\n                return this;\n            }\n            // Grow the flattened doc\n            this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));\n        }\n    }\n}\nif (typeof Symbol != \"undefined\") {\n    RegExpCursor.prototype[Symbol.iterator] = MultilineRegExpCursor.prototype[Symbol.iterator] =\n        function () { return this; };\n}\nfunction validRegExp(source) {\n    try {\n        new RegExp(source, baseFlags);\n        return true;\n    }\n    catch (_a) {\n        return false;\n    }\n}\nfunction toCharEnd(text, pos) {\n    if (pos >= text.length)\n        return pos;\n    let line = text.lineAt(pos), next;\n    while (pos < line.to && (next = line.text.charCodeAt(pos - line.from)) >= 0xDC00 && next < 0xE000)\n        pos++;\n    return pos;\n}\n\nfunction createLineDialog(view) {\n    let line = String(view.state.doc.lineAt(view.state.selection.main.head).number);\n    let input = elt(\"input\", { class: \"cm-textfield\", name: \"line\", value: line });\n    let dom = elt(\"form\", {\n        class: \"cm-gotoLine\",\n        onkeydown: (event) => {\n            if (event.keyCode == 27) { // Escape\n                event.preventDefault();\n                view.dispatch({ effects: dialogEffect.of(false) });\n                view.focus();\n            }\n            else if (event.keyCode == 13) { // Enter\n                event.preventDefault();\n                go();\n            }\n        },\n        onsubmit: (event) => {\n            event.preventDefault();\n            go();\n        }\n    }, elt(\"label\", view.state.phrase(\"Go to line\"), \": \", input), \" \", elt(\"button\", { class: \"cm-button\", type: \"submit\" }, view.state.phrase(\"go\")), elt(\"button\", {\n        name: \"close\",\n        onclick: () => {\n            view.dispatch({ effects: dialogEffect.of(false) });\n            view.focus();\n        },\n        \"aria-label\": view.state.phrase(\"close\"),\n        type: \"button\"\n    }, [\"×\"]));\n    function go() {\n        let match = /^([+-])?(\\d+)?(:\\d+)?(%)?$/.exec(input.value);\n        if (!match)\n            return;\n        let { state } = view, startLine = state.doc.lineAt(state.selection.main.head);\n        let [, sign, ln, cl, percent] = match;\n        let col = cl ? +cl.slice(1) : 0;\n        let line = ln ? +ln : startLine.number;\n        if (ln && percent) {\n            let pc = line / 100;\n            if (sign)\n                pc = pc * (sign == \"-\" ? -1 : 1) + (startLine.number / state.doc.lines);\n            line = Math.round(state.doc.lines * pc);\n        }\n        else if (ln && sign) {\n            line = line * (sign == \"-\" ? -1 : 1) + startLine.number;\n        }\n        let docLine = state.doc.line(Math.max(1, Math.min(state.doc.lines, line)));\n        let selection = EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length)));\n        view.dispatch({\n            effects: [dialogEffect.of(false), EditorView.scrollIntoView(selection.from, { y: 'center' })],\n            selection,\n        });\n        view.focus();\n    }\n    return { dom };\n}\nconst dialogEffect = /*@__PURE__*/StateEffect.define();\nconst dialogField = /*@__PURE__*/StateField.define({\n    create() { return true; },\n    update(value, tr) {\n        for (let e of tr.effects)\n            if (e.is(dialogEffect))\n                value = e.value;\n        return value;\n    },\n    provide: f => showPanel.from(f, val => val ? createLineDialog : null)\n});\n/**\nCommand that shows a dialog asking the user for a line number, and\nwhen a valid position is provided, moves the cursor to that line.\n\nSupports line numbers, relative line offsets prefixed with `+` or\n`-`, document percentages suffixed with `%`, and an optional\ncolumn position by adding `:` and a second number after the line\nnumber.\n*/\nconst gotoLine = view => {\n    let panel = getPanel(view, createLineDialog);\n    if (!panel) {\n        let effects = [dialogEffect.of(true)];\n        if (view.state.field(dialogField, false) == null)\n            effects.push(StateEffect.appendConfig.of([dialogField, baseTheme$1]));\n        view.dispatch({ effects });\n        panel = getPanel(view, createLineDialog);\n    }\n    if (panel)\n        panel.dom.querySelector(\"input\").select();\n    return true;\n};\nconst baseTheme$1 = /*@__PURE__*/EditorView.baseTheme({\n    \".cm-panel.cm-gotoLine\": {\n        padding: \"2px 6px 4px\",\n        position: \"relative\",\n        \"& label\": { fontSize: \"80%\" },\n        \"& [name=close]\": {\n            position: \"absolute\",\n            top: \"0\", bottom: \"0\",\n            right: \"4px\",\n            backgroundColor: \"inherit\",\n            border: \"none\",\n            font: \"inherit\",\n            padding: \"0\"\n        }\n    }\n});\n\nconst defaultHighlightOptions = {\n    highlightWordAroundCursor: false,\n    minSelectionLength: 1,\n    maxMatches: 100,\n    wholeWords: false\n};\nconst highlightConfig = /*@__PURE__*/Facet.define({\n    combine(options) {\n        return combineConfig(options, defaultHighlightOptions, {\n            highlightWordAroundCursor: (a, b) => a || b,\n            minSelectionLength: Math.min,\n            maxMatches: Math.min\n        });\n    }\n});\n/**\nThis extension highlights text that matches the selection. It uses\nthe `\"cm-selectionMatch\"` class for the highlighting. When\n`highlightWordAroundCursor` is enabled, the word at the cursor\nitself will be highlighted with `\"cm-selectionMatch-main\"`.\n*/\nfunction highlightSelectionMatches(options) {\n    let ext = [defaultTheme, matchHighlighter];\n    if (options)\n        ext.push(highlightConfig.of(options));\n    return ext;\n}\nconst matchDeco = /*@__PURE__*/Decoration.mark({ class: \"cm-selectionMatch\" });\nconst mainMatchDeco = /*@__PURE__*/Decoration.mark({ class: \"cm-selectionMatch cm-selectionMatch-main\" });\n// Whether the characters directly outside the given positions are non-word characters\nfunction insideWordBoundaries(check, state, from, to) {\n    return (from == 0 || check(state.sliceDoc(from - 1, from)) != CharCategory.Word) &&\n        (to == state.doc.length || check(state.sliceDoc(to, to + 1)) != CharCategory.Word);\n}\n// Whether the characters directly at the given positions are word characters\nfunction insideWord(check, state, from, to) {\n    return check(state.sliceDoc(from, from + 1)) == CharCategory.Word\n        && check(state.sliceDoc(to - 1, to)) == CharCategory.Word;\n}\nconst matchHighlighter = /*@__PURE__*/ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.decorations = this.getDeco(view);\n    }\n    update(update) {\n        if (update.selectionSet || update.docChanged || update.viewportChanged)\n            this.decorations = this.getDeco(update.view);\n    }\n    getDeco(view) {\n        let conf = view.state.facet(highlightConfig);\n        let { state } = view, sel = state.selection;\n        if (sel.ranges.length > 1)\n            return Decoration.none;\n        let range = sel.main, query, check = null;\n        if (range.empty) {\n            if (!conf.highlightWordAroundCursor)\n                return Decoration.none;\n            let word = state.wordAt(range.head);\n            if (!word)\n                return Decoration.none;\n            check = state.charCategorizer(range.head);\n            query = state.sliceDoc(word.from, word.to);\n        }\n        else {\n            let len = range.to - range.from;\n            if (len < conf.minSelectionLength || len > 200)\n                return Decoration.none;\n            if (conf.wholeWords) {\n                query = state.sliceDoc(range.from, range.to); // TODO: allow and include leading/trailing space?\n                check = state.charCategorizer(range.head);\n                if (!(insideWordBoundaries(check, state, range.from, range.to) &&\n                    insideWord(check, state, range.from, range.to)))\n                    return Decoration.none;\n            }\n            else {\n                query = state.sliceDoc(range.from, range.to);\n                if (!query)\n                    return Decoration.none;\n            }\n        }\n        let deco = [];\n        for (let part of view.visibleRanges) {\n            let cursor = new SearchCursor(state.doc, query, part.from, part.to);\n            while (!cursor.next().done) {\n                let { from, to } = cursor.value;\n                if (!check || insideWordBoundaries(check, state, from, to)) {\n                    if (range.empty && from <= range.from && to >= range.to)\n                        deco.push(mainMatchDeco.range(from, to));\n                    else if (from >= range.to || to <= range.from)\n                        deco.push(matchDeco.range(from, to));\n                    if (deco.length > conf.maxMatches)\n                        return Decoration.none;\n                }\n            }\n        }\n        return Decoration.set(deco);\n    }\n}, {\n    decorations: v => v.decorations\n});\nconst defaultTheme = /*@__PURE__*/EditorView.baseTheme({\n    \".cm-selectionMatch\": { backgroundColor: \"#99ff7780\" },\n    \".cm-searchMatch .cm-selectionMatch\": { backgroundColor: \"transparent\" }\n});\n// Select the words around the cursors.\nconst selectWord = ({ state, dispatch }) => {\n    let { selection } = state;\n    let newSel = EditorSelection.create(selection.ranges.map(range => state.wordAt(range.head) || EditorSelection.cursor(range.head)), selection.mainIndex);\n    if (newSel.eq(selection))\n        return false;\n    dispatch(state.update({ selection: newSel }));\n    return true;\n};\n// Find next occurrence of query relative to last cursor. Wrap around\n// the document if there are no more matches.\nfunction findNextOccurrence(state, query) {\n    let { main, ranges } = state.selection;\n    let word = state.wordAt(main.head), fullWord = word && word.from == main.from && word.to == main.to;\n    for (let cycled = false, cursor = new SearchCursor(state.doc, query, ranges[ranges.length - 1].to);;) {\n        cursor.next();\n        if (cursor.done) {\n            if (cycled)\n                return null;\n            cursor = new SearchCursor(state.doc, query, 0, Math.max(0, ranges[ranges.length - 1].from - 1));\n            cycled = true;\n        }\n        else {\n            if (cycled && ranges.some(r => r.from == cursor.value.from))\n                continue;\n            if (fullWord) {\n                let word = state.wordAt(cursor.value.from);\n                if (!word || word.from != cursor.value.from || word.to != cursor.value.to)\n                    continue;\n            }\n            return cursor.value;\n        }\n    }\n}\n/**\nSelect next occurrence of the current selection. Expand selection\nto the surrounding word when the selection is empty.\n*/\nconst selectNextOccurrence = ({ state, dispatch }) => {\n    let { ranges } = state.selection;\n    if (ranges.some(sel => sel.from === sel.to))\n        return selectWord({ state, dispatch });\n    let searchedText = state.sliceDoc(ranges[0].from, ranges[0].to);\n    if (state.selection.ranges.some(r => state.sliceDoc(r.from, r.to) != searchedText))\n        return false;\n    let range = findNextOccurrence(state, searchedText);\n    if (!range)\n        return false;\n    dispatch(state.update({\n        selection: state.selection.addRange(EditorSelection.range(range.from, range.to), false),\n        effects: EditorView.scrollIntoView(range.to)\n    }));\n    return true;\n};\n\nconst searchConfigFacet = /*@__PURE__*/Facet.define({\n    combine(configs) {\n        return combineConfig(configs, {\n            top: false,\n            caseSensitive: false,\n            literal: false,\n            regexp: false,\n            wholeWord: false,\n            createPanel: view => new SearchPanel(view),\n            scrollToMatch: range => EditorView.scrollIntoView(range)\n        });\n    }\n});\n/**\nAdd search state to the editor configuration, and optionally\nconfigure the search extension.\n([`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel) will automatically\nenable this if it isn't already on).\n*/\nfunction search(config) {\n    return config ? [searchConfigFacet.of(config), searchExtensions] : searchExtensions;\n}\n/**\nA search query. Part of the editor's search state.\n*/\nclass SearchQuery {\n    /**\n    Create a query object.\n    */\n    constructor(config) {\n        this.search = config.search;\n        this.caseSensitive = !!config.caseSensitive;\n        this.literal = !!config.literal;\n        this.regexp = !!config.regexp;\n        this.replace = config.replace || \"\";\n        this.valid = !!this.search && (!this.regexp || validRegExp(this.search));\n        this.unquoted = this.unquote(this.search);\n        this.wholeWord = !!config.wholeWord;\n    }\n    /**\n    @internal\n    */\n    unquote(text) {\n        return this.literal ? text :\n            text.replace(/\\\\([nrt\\\\])/g, (_, ch) => ch == \"n\" ? \"\\n\" : ch == \"r\" ? \"\\r\" : ch == \"t\" ? \"\\t\" : \"\\\\\");\n    }\n    /**\n    Compare this query to another query.\n    */\n    eq(other) {\n        return this.search == other.search && this.replace == other.replace &&\n            this.caseSensitive == other.caseSensitive && this.regexp == other.regexp &&\n            this.wholeWord == other.wholeWord;\n    }\n    /**\n    @internal\n    */\n    create() {\n        return this.regexp ? new RegExpQuery(this) : new StringQuery(this);\n    }\n    /**\n    Get a search cursor for this query, searching through the given\n    range in the given state.\n    */\n    getCursor(state, from = 0, to) {\n        let st = state.doc ? state : EditorState.create({ doc: state });\n        if (to == null)\n            to = st.doc.length;\n        return this.regexp ? regexpCursor(this, st, from, to) : stringCursor(this, st, from, to);\n    }\n}\nclass QueryType {\n    constructor(spec) {\n        this.spec = spec;\n    }\n}\nfunction stringCursor(spec, state, from, to) {\n    return new SearchCursor(state.doc, spec.unquoted, from, to, spec.caseSensitive ? undefined : x => x.toLowerCase(), spec.wholeWord ? stringWordTest(state.doc, state.charCategorizer(state.selection.main.head)) : undefined);\n}\nfunction stringWordTest(doc, categorizer) {\n    return (from, to, buf, bufPos) => {\n        if (bufPos > from || bufPos + buf.length < to) {\n            bufPos = Math.max(0, from - 2);\n            buf = doc.sliceString(bufPos, Math.min(doc.length, to + 2));\n        }\n        return (categorizer(charBefore(buf, from - bufPos)) != CharCategory.Word ||\n            categorizer(charAfter(buf, from - bufPos)) != CharCategory.Word) &&\n            (categorizer(charAfter(buf, to - bufPos)) != CharCategory.Word ||\n                categorizer(charBefore(buf, to - bufPos)) != CharCategory.Word);\n    };\n}\nclass StringQuery extends QueryType {\n    constructor(spec) {\n        super(spec);\n    }\n    nextMatch(state, curFrom, curTo) {\n        let cursor = stringCursor(this.spec, state, curTo, state.doc.length).nextOverlapping();\n        if (cursor.done) {\n            let end = Math.min(state.doc.length, curFrom + this.spec.unquoted.length);\n            cursor = stringCursor(this.spec, state, 0, end).nextOverlapping();\n        }\n        return cursor.done || cursor.value.from == curFrom && cursor.value.to == curTo ? null : cursor.value;\n    }\n    // Searching in reverse is, rather than implementing an inverted search\n    // cursor, done by scanning chunk after chunk forward.\n    prevMatchInRange(state, from, to) {\n        for (let pos = to;;) {\n            let start = Math.max(from, pos - 10000 /* FindPrev.ChunkSize */ - this.spec.unquoted.length);\n            let cursor = stringCursor(this.spec, state, start, pos), range = null;\n            while (!cursor.nextOverlapping().done)\n                range = cursor.value;\n            if (range)\n                return range;\n            if (start == from)\n                return null;\n            pos -= 10000 /* FindPrev.ChunkSize */;\n        }\n    }\n    prevMatch(state, curFrom, curTo) {\n        let found = this.prevMatchInRange(state, 0, curFrom);\n        if (!found)\n            found = this.prevMatchInRange(state, Math.max(0, curTo - this.spec.unquoted.length), state.doc.length);\n        return found && (found.from != curFrom || found.to != curTo) ? found : null;\n    }\n    getReplacement(_result) { return this.spec.unquote(this.spec.replace); }\n    matchAll(state, limit) {\n        let cursor = stringCursor(this.spec, state, 0, state.doc.length), ranges = [];\n        while (!cursor.next().done) {\n            if (ranges.length >= limit)\n                return null;\n            ranges.push(cursor.value);\n        }\n        return ranges;\n    }\n    highlight(state, from, to, add) {\n        let cursor = stringCursor(this.spec, state, Math.max(0, from - this.spec.unquoted.length), Math.min(to + this.spec.unquoted.length, state.doc.length));\n        while (!cursor.next().done)\n            add(cursor.value.from, cursor.value.to);\n    }\n}\nfunction regexpCursor(spec, state, from, to) {\n    return new RegExpCursor(state.doc, spec.search, {\n        ignoreCase: !spec.caseSensitive,\n        test: spec.wholeWord ? regexpWordTest(state.charCategorizer(state.selection.main.head)) : undefined\n    }, from, to);\n}\nfunction charBefore(str, index) {\n    return str.slice(findClusterBreak(str, index, false), index);\n}\nfunction charAfter(str, index) {\n    return str.slice(index, findClusterBreak(str, index));\n}\nfunction regexpWordTest(categorizer) {\n    return (_from, _to, match) => !match[0].length ||\n        (categorizer(charBefore(match.input, match.index)) != CharCategory.Word ||\n            categorizer(charAfter(match.input, match.index)) != CharCategory.Word) &&\n            (categorizer(charAfter(match.input, match.index + match[0].length)) != CharCategory.Word ||\n                categorizer(charBefore(match.input, match.index + match[0].length)) != CharCategory.Word);\n}\nclass RegExpQuery extends QueryType {\n    nextMatch(state, curFrom, curTo) {\n        let cursor = regexpCursor(this.spec, state, curTo, state.doc.length).next();\n        if (cursor.done)\n            cursor = regexpCursor(this.spec, state, 0, curFrom).next();\n        return cursor.done ? null : cursor.value;\n    }\n    prevMatchInRange(state, from, to) {\n        for (let size = 1;; size++) {\n            let start = Math.max(from, to - size * 10000 /* FindPrev.ChunkSize */);\n            let cursor = regexpCursor(this.spec, state, start, to), range = null;\n            while (!cursor.next().done)\n                range = cursor.value;\n            if (range && (start == from || range.from > start + 10))\n                return range;\n            if (start == from)\n                return null;\n        }\n    }\n    prevMatch(state, curFrom, curTo) {\n        return this.prevMatchInRange(state, 0, curFrom) ||\n            this.prevMatchInRange(state, curTo, state.doc.length);\n    }\n    getReplacement(result) {\n        return this.spec.unquote(this.spec.replace).replace(/\\$([$&]|\\d+)/g, (m, i) => {\n            if (i == \"&\")\n                return result.match[0];\n            if (i == \"$\")\n                return \"$\";\n            for (let l = i.length; l > 0; l--) {\n                let n = +i.slice(0, l);\n                if (n > 0 && n < result.match.length)\n                    return result.match[n] + i.slice(l);\n            }\n            return m;\n        });\n    }\n    matchAll(state, limit) {\n        let cursor = regexpCursor(this.spec, state, 0, state.doc.length), ranges = [];\n        while (!cursor.next().done) {\n            if (ranges.length >= limit)\n                return null;\n            ranges.push(cursor.value);\n        }\n        return ranges;\n    }\n    highlight(state, from, to, add) {\n        let cursor = regexpCursor(this.spec, state, Math.max(0, from - 250 /* RegExp.HighlightMargin */), Math.min(to + 250 /* RegExp.HighlightMargin */, state.doc.length));\n        while (!cursor.next().done)\n            add(cursor.value.from, cursor.value.to);\n    }\n}\n/**\nA state effect that updates the current search query. Note that\nthis only has an effect if the search state has been initialized\n(by including [`search`](https://codemirror.net/6/docs/ref/#search.search) in your configuration or\nby running [`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel) at least\nonce).\n*/\nconst setSearchQuery = /*@__PURE__*/StateEffect.define();\nconst togglePanel = /*@__PURE__*/StateEffect.define();\nconst searchState = /*@__PURE__*/StateField.define({\n    create(state) {\n        return new SearchState(defaultQuery(state).create(), null);\n    },\n    update(value, tr) {\n        for (let effect of tr.effects) {\n            if (effect.is(setSearchQuery))\n                value = new SearchState(effect.value.create(), value.panel);\n            else if (effect.is(togglePanel))\n                value = new SearchState(value.query, effect.value ? createSearchPanel : null);\n        }\n        return value;\n    },\n    provide: f => showPanel.from(f, val => val.panel)\n});\n/**\nGet the current search query from an editor state.\n*/\nfunction getSearchQuery(state) {\n    let curState = state.field(searchState, false);\n    return curState ? curState.query.spec : defaultQuery(state);\n}\n/**\nQuery whether the search panel is open in the given editor state.\n*/\nfunction searchPanelOpen(state) {\n    var _a;\n    return ((_a = state.field(searchState, false)) === null || _a === void 0 ? void 0 : _a.panel) != null;\n}\nclass SearchState {\n    constructor(query, panel) {\n        this.query = query;\n        this.panel = panel;\n    }\n}\nconst matchMark = /*@__PURE__*/Decoration.mark({ class: \"cm-searchMatch\" }), selectedMatchMark = /*@__PURE__*/Decoration.mark({ class: \"cm-searchMatch cm-searchMatch-selected\" });\nconst searchHighlighter = /*@__PURE__*/ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.view = view;\n        this.decorations = this.highlight(view.state.field(searchState));\n    }\n    update(update) {\n        let state = update.state.field(searchState);\n        if (state != update.startState.field(searchState) || update.docChanged || update.selectionSet || update.viewportChanged)\n            this.decorations = this.highlight(state);\n    }\n    highlight({ query, panel }) {\n        if (!panel || !query.spec.valid)\n            return Decoration.none;\n        let { view } = this;\n        let builder = new RangeSetBuilder();\n        for (let i = 0, ranges = view.visibleRanges, l = ranges.length; i < l; i++) {\n            let { from, to } = ranges[i];\n            while (i < l - 1 && to > ranges[i + 1].from - 2 * 250 /* RegExp.HighlightMargin */)\n                to = ranges[++i].to;\n            query.highlight(view.state, from, to, (from, to) => {\n                let selected = view.state.selection.ranges.some(r => r.from == from && r.to == to);\n                builder.add(from, to, selected ? selectedMatchMark : matchMark);\n            });\n        }\n        return builder.finish();\n    }\n}, {\n    decorations: v => v.decorations\n});\nfunction searchCommand(f) {\n    return view => {\n        let state = view.state.field(searchState, false);\n        return state && state.query.spec.valid ? f(view, state) : openSearchPanel(view);\n    };\n}\n/**\nOpen the search panel if it isn't already open, and move the\nselection to the first match after the current main selection.\nWill wrap around to the start of the document when it reaches the\nend.\n*/\nconst findNext = /*@__PURE__*/searchCommand((view, { query }) => {\n    let { to } = view.state.selection.main;\n    let next = query.nextMatch(view.state, to, to);\n    if (!next)\n        return false;\n    let selection = EditorSelection.single(next.from, next.to);\n    let config = view.state.facet(searchConfigFacet);\n    view.dispatch({\n        selection,\n        effects: [announceMatch(view, next), config.scrollToMatch(selection.main, view)],\n        userEvent: \"select.search\"\n    });\n    selectSearchInput(view);\n    return true;\n});\n/**\nMove the selection to the previous instance of the search query,\nbefore the current main selection. Will wrap past the start\nof the document to start searching at the end again.\n*/\nconst findPrevious = /*@__PURE__*/searchCommand((view, { query }) => {\n    let { state } = view, { from } = state.selection.main;\n    let prev = query.prevMatch(state, from, from);\n    if (!prev)\n        return false;\n    let selection = EditorSelection.single(prev.from, prev.to);\n    let config = view.state.facet(searchConfigFacet);\n    view.dispatch({\n        selection,\n        effects: [announceMatch(view, prev), config.scrollToMatch(selection.main, view)],\n        userEvent: \"select.search\"\n    });\n    selectSearchInput(view);\n    return true;\n});\n/**\nSelect all instances of the search query.\n*/\nconst selectMatches = /*@__PURE__*/searchCommand((view, { query }) => {\n    let ranges = query.matchAll(view.state, 1000);\n    if (!ranges || !ranges.length)\n        return false;\n    view.dispatch({\n        selection: EditorSelection.create(ranges.map(r => EditorSelection.range(r.from, r.to))),\n        userEvent: \"select.search.matches\"\n    });\n    return true;\n});\n/**\nSelect all instances of the currently selected text.\n*/\nconst selectSelectionMatches = ({ state, dispatch }) => {\n    let sel = state.selection;\n    if (sel.ranges.length > 1 || sel.main.empty)\n        return false;\n    let { from, to } = sel.main;\n    let ranges = [], main = 0;\n    for (let cur = new SearchCursor(state.doc, state.sliceDoc(from, to)); !cur.next().done;) {\n        if (ranges.length > 1000)\n            return false;\n        if (cur.value.from == from)\n            main = ranges.length;\n        ranges.push(EditorSelection.range(cur.value.from, cur.value.to));\n    }\n    dispatch(state.update({\n        selection: EditorSelection.create(ranges, main),\n        userEvent: \"select.search.matches\"\n    }));\n    return true;\n};\n/**\nReplace the current match of the search query.\n*/\nconst replaceNext = /*@__PURE__*/searchCommand((view, { query }) => {\n    let { state } = view, { from, to } = state.selection.main;\n    if (state.readOnly)\n        return false;\n    let match = query.nextMatch(state, from, from);\n    if (!match)\n        return false;\n    let next = match;\n    let changes = [], selection, replacement;\n    let effects = [];\n    if (next.from == from && next.to == to) {\n        replacement = state.toText(query.getReplacement(next));\n        changes.push({ from: next.from, to: next.to, insert: replacement });\n        next = query.nextMatch(state, next.from, next.to);\n        effects.push(EditorView.announce.of(state.phrase(\"replaced match on line $\", state.doc.lineAt(from).number) + \".\"));\n    }\n    if (next) {\n        let off = changes.length == 0 || changes[0].from >= match.to ? 0 : match.to - match.from - replacement.length;\n        selection = EditorSelection.single(next.from - off, next.to - off);\n        effects.push(announceMatch(view, next));\n        effects.push(state.facet(searchConfigFacet).scrollToMatch(selection.main, view));\n    }\n    view.dispatch({\n        changes, selection, effects,\n        userEvent: \"input.replace\"\n    });\n    return true;\n});\n/**\nReplace all instances of the search query with the given\nreplacement.\n*/\nconst replaceAll = /*@__PURE__*/searchCommand((view, { query }) => {\n    if (view.state.readOnly)\n        return false;\n    let changes = query.matchAll(view.state, 1e9).map(match => {\n        let { from, to } = match;\n        return { from, to, insert: query.getReplacement(match) };\n    });\n    if (!changes.length)\n        return false;\n    let announceText = view.state.phrase(\"replaced $ matches\", changes.length) + \".\";\n    view.dispatch({\n        changes,\n        effects: EditorView.announce.of(announceText),\n        userEvent: \"input.replace.all\"\n    });\n    return true;\n});\nfunction createSearchPanel(view) {\n    return view.state.facet(searchConfigFacet).createPanel(view);\n}\nfunction defaultQuery(state, fallback) {\n    var _a, _b, _c, _d, _e;\n    let sel = state.selection.main;\n    let selText = sel.empty || sel.to > sel.from + 100 ? \"\" : state.sliceDoc(sel.from, sel.to);\n    if (fallback && !selText)\n        return fallback;\n    let config = state.facet(searchConfigFacet);\n    return new SearchQuery({\n        search: ((_a = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _a !== void 0 ? _a : config.literal) ? selText : selText.replace(/\\n/g, \"\\\\n\"),\n        caseSensitive: (_b = fallback === null || fallback === void 0 ? void 0 : fallback.caseSensitive) !== null && _b !== void 0 ? _b : config.caseSensitive,\n        literal: (_c = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _c !== void 0 ? _c : config.literal,\n        regexp: (_d = fallback === null || fallback === void 0 ? void 0 : fallback.regexp) !== null && _d !== void 0 ? _d : config.regexp,\n        wholeWord: (_e = fallback === null || fallback === void 0 ? void 0 : fallback.wholeWord) !== null && _e !== void 0 ? _e : config.wholeWord\n    });\n}\nfunction getSearchInput(view) {\n    let panel = getPanel(view, createSearchPanel);\n    return panel && panel.dom.querySelector(\"[main-field]\");\n}\nfunction selectSearchInput(view) {\n    let input = getSearchInput(view);\n    if (input && input == view.root.activeElement)\n        input.select();\n}\n/**\nMake sure the search panel is open and focused.\n*/\nconst openSearchPanel = view => {\n    let state = view.state.field(searchState, false);\n    if (state && state.panel) {\n        let searchInput = getSearchInput(view);\n        if (searchInput && searchInput != view.root.activeElement) {\n            let query = defaultQuery(view.state, state.query.spec);\n            if (query.valid)\n                view.dispatch({ effects: setSearchQuery.of(query) });\n            searchInput.focus();\n            searchInput.select();\n        }\n    }\n    else {\n        view.dispatch({ effects: [\n                togglePanel.of(true),\n                state ? setSearchQuery.of(defaultQuery(view.state, state.query.spec)) : StateEffect.appendConfig.of(searchExtensions)\n            ] });\n    }\n    return true;\n};\n/**\nClose the search panel.\n*/\nconst closeSearchPanel = view => {\n    let state = view.state.field(searchState, false);\n    if (!state || !state.panel)\n        return false;\n    let panel = getPanel(view, createSearchPanel);\n    if (panel && panel.dom.contains(view.root.activeElement))\n        view.focus();\n    view.dispatch({ effects: togglePanel.of(false) });\n    return true;\n};\n/**\nDefault search-related key bindings.\n\n - Mod-f: [`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel)\n - F3, Mod-g: [`findNext`](https://codemirror.net/6/docs/ref/#search.findNext)\n - Shift-F3, Shift-Mod-g: [`findPrevious`](https://codemirror.net/6/docs/ref/#search.findPrevious)\n - Mod-Alt-g: [`gotoLine`](https://codemirror.net/6/docs/ref/#search.gotoLine)\n - Mod-d: [`selectNextOccurrence`](https://codemirror.net/6/docs/ref/#search.selectNextOccurrence)\n*/\nconst searchKeymap = [\n    { key: \"Mod-f\", run: openSearchPanel, scope: \"editor search-panel\" },\n    { key: \"F3\", run: findNext, shift: findPrevious, scope: \"editor search-panel\", preventDefault: true },\n    { key: \"Mod-g\", run: findNext, shift: findPrevious, scope: \"editor search-panel\", preventDefault: true },\n    { key: \"Escape\", run: closeSearchPanel, scope: \"editor search-panel\" },\n    { key: \"Mod-Shift-l\", run: selectSelectionMatches },\n    { key: \"Mod-Alt-g\", run: gotoLine },\n    { key: \"Mod-d\", run: selectNextOccurrence, preventDefault: true },\n];\nclass SearchPanel {\n    constructor(view) {\n        this.view = view;\n        let query = this.query = view.state.field(searchState).query.spec;\n        this.commit = this.commit.bind(this);\n        this.searchField = elt(\"input\", {\n            value: query.search,\n            placeholder: phrase(view, \"Find\"),\n            \"aria-label\": phrase(view, \"Find\"),\n            class: \"cm-textfield\",\n            name: \"search\",\n            form: \"\",\n            \"main-field\": \"true\",\n            onchange: this.commit,\n            onkeyup: this.commit\n        });\n        this.replaceField = elt(\"input\", {\n            value: query.replace,\n            placeholder: phrase(view, \"Replace\"),\n            \"aria-label\": phrase(view, \"Replace\"),\n            class: \"cm-textfield\",\n            name: \"replace\",\n            form: \"\",\n            onchange: this.commit,\n            onkeyup: this.commit\n        });\n        this.caseField = elt(\"input\", {\n            type: \"checkbox\",\n            name: \"case\",\n            form: \"\",\n            checked: query.caseSensitive,\n            onchange: this.commit\n        });\n        this.reField = elt(\"input\", {\n            type: \"checkbox\",\n            name: \"re\",\n            form: \"\",\n            checked: query.regexp,\n            onchange: this.commit\n        });\n        this.wordField = elt(\"input\", {\n            type: \"checkbox\",\n            name: \"word\",\n            form: \"\",\n            checked: query.wholeWord,\n            onchange: this.commit\n        });\n        function button(name, onclick, content) {\n            return elt(\"button\", { class: \"cm-button\", name, onclick, type: \"button\" }, content);\n        }\n        this.dom = elt(\"div\", { onkeydown: (e) => this.keydown(e), class: \"cm-search\" }, [\n            this.searchField,\n            button(\"next\", () => findNext(view), [phrase(view, \"next\")]),\n            button(\"prev\", () => findPrevious(view), [phrase(view, \"previous\")]),\n            button(\"select\", () => selectMatches(view), [phrase(view, \"all\")]),\n            elt(\"label\", null, [this.caseField, phrase(view, \"match case\")]),\n            elt(\"label\", null, [this.reField, phrase(view, \"regexp\")]),\n            elt(\"label\", null, [this.wordField, phrase(view, \"by word\")]),\n            ...view.state.readOnly ? [] : [\n                elt(\"br\"),\n                this.replaceField,\n                button(\"replace\", () => replaceNext(view), [phrase(view, \"replace\")]),\n                button(\"replaceAll\", () => replaceAll(view), [phrase(view, \"replace all\")])\n            ],\n            elt(\"button\", {\n                name: \"close\",\n                onclick: () => closeSearchPanel(view),\n                \"aria-label\": phrase(view, \"close\"),\n                type: \"button\"\n            }, [\"×\"])\n        ]);\n    }\n    commit() {\n        let query = new SearchQuery({\n            search: this.searchField.value,\n            caseSensitive: this.caseField.checked,\n            regexp: this.reField.checked,\n            wholeWord: this.wordField.checked,\n            replace: this.replaceField.value,\n        });\n        if (!query.eq(this.query)) {\n            this.query = query;\n            this.view.dispatch({ effects: setSearchQuery.of(query) });\n        }\n    }\n    keydown(e) {\n        if (runScopeHandlers(this.view, e, \"search-panel\")) {\n            e.preventDefault();\n        }\n        else if (e.keyCode == 13 && e.target == this.searchField) {\n            e.preventDefault();\n            (e.shiftKey ? findPrevious : findNext)(this.view);\n        }\n        else if (e.keyCode == 13 && e.target == this.replaceField) {\n            e.preventDefault();\n            replaceNext(this.view);\n        }\n    }\n    update(update) {\n        for (let tr of update.transactions)\n            for (let effect of tr.effects) {\n                if (effect.is(setSearchQuery) && !effect.value.eq(this.query))\n                    this.setQuery(effect.value);\n            }\n    }\n    setQuery(query) {\n        this.query = query;\n        this.searchField.value = query.search;\n        this.replaceField.value = query.replace;\n        this.caseField.checked = query.caseSensitive;\n        this.reField.checked = query.regexp;\n        this.wordField.checked = query.wholeWord;\n    }\n    mount() {\n        this.searchField.select();\n    }\n    get pos() { return 80; }\n    get top() { return this.view.state.facet(searchConfigFacet).top; }\n}\nfunction phrase(view, phrase) { return view.state.phrase(phrase); }\nconst AnnounceMargin = 30;\nconst Break = /[\\s\\.,:;?!]/;\nfunction announceMatch(view, { from, to }) {\n    let line = view.state.doc.lineAt(from), lineEnd = view.state.doc.lineAt(to).to;\n    let start = Math.max(line.from, from - AnnounceMargin), end = Math.min(lineEnd, to + AnnounceMargin);\n    let text = view.state.sliceDoc(start, end);\n    if (start != line.from) {\n        for (let i = 0; i < AnnounceMargin; i++)\n            if (!Break.test(text[i + 1]) && Break.test(text[i])) {\n                text = text.slice(i);\n                break;\n            }\n    }\n    if (end != lineEnd) {\n        for (let i = text.length - 1; i > text.length - AnnounceMargin; i--)\n            if (!Break.test(text[i - 1]) && Break.test(text[i])) {\n                text = text.slice(0, i);\n                break;\n            }\n    }\n    return EditorView.announce.of(`${view.state.phrase(\"current match\")}. ${text} ${view.state.phrase(\"on line\")} ${line.number}.`);\n}\nconst baseTheme = /*@__PURE__*/EditorView.baseTheme({\n    \".cm-panel.cm-search\": {\n        padding: \"2px 6px 4px\",\n        position: \"relative\",\n        \"& [name=close]\": {\n            position: \"absolute\",\n            top: \"0\",\n            right: \"4px\",\n            backgroundColor: \"inherit\",\n            border: \"none\",\n            font: \"inherit\",\n            padding: 0,\n            margin: 0\n        },\n        \"& input, & button, & label\": {\n            margin: \".2em .6em .2em 0\"\n        },\n        \"& input[type=checkbox]\": {\n            marginRight: \".2em\"\n        },\n        \"& label\": {\n            fontSize: \"80%\",\n            whiteSpace: \"pre\"\n        }\n    },\n    \"&light .cm-searchMatch\": { backgroundColor: \"#ffff0054\" },\n    \"&dark .cm-searchMatch\": { backgroundColor: \"#00ffff8a\" },\n    \"&light .cm-searchMatch-selected\": { backgroundColor: \"#ff6a0054\" },\n    \"&dark .cm-searchMatch-selected\": { backgroundColor: \"#ff00ff8a\" }\n});\nconst searchExtensions = [\n    searchState,\n    /*@__PURE__*/Prec.low(searchHighlighter),\n    baseTheme\n];\n\nexport { RegExpCursor, SearchCursor, SearchQuery, closeSearchPanel, findNext, findPrevious, getSearchQuery, gotoLine, highlightSelectionMatches, openSearchPanel, replaceAll, replaceNext, search, searchKeymap, searchPanelOpen, selectMatches, selectNextOccurrence, selectSelectionMatches, setSearchQuery };\n","import { Decoration, showPanel, EditorView, ViewPlugin, gutter, showTooltip, hoverTooltip, getPanel, logException, WidgetType, GutterMarker } from '@codemirror/view';\nimport { StateEffect, StateField, Facet, combineConfig, RangeSet, RangeSetBuilder } from '@codemirror/state';\nimport elt from 'crelt';\n\nclass SelectedDiagnostic {\n    constructor(from, to, diagnostic) {\n        this.from = from;\n        this.to = to;\n        this.diagnostic = diagnostic;\n    }\n}\nclass LintState {\n    constructor(diagnostics, panel, selected) {\n        this.diagnostics = diagnostics;\n        this.panel = panel;\n        this.selected = selected;\n    }\n    static init(diagnostics, panel, state) {\n        // Filter the list of diagnostics for which to create markers\n        let diagnosticFilter = state.facet(lintConfig).markerFilter;\n        if (diagnosticFilter)\n            diagnostics = diagnosticFilter(diagnostics, state);\n        let sorted = diagnostics.slice().sort((a, b) => a.from - b.from || a.to - b.to);\n        let deco = new RangeSetBuilder(), active = [], pos = 0;\n        for (let i = 0;;) {\n            let next = i == sorted.length ? null : sorted[i];\n            if (!next && !active.length)\n                break;\n            let from, to;\n            if (active.length) {\n                from = pos;\n                to = active.reduce((p, d) => Math.min(p, d.to), next && next.from > from ? next.from : 1e8);\n            }\n            else {\n                from = next.from;\n                to = next.to;\n                active.push(next);\n                i++;\n            }\n            while (i < sorted.length) {\n                let next = sorted[i];\n                if (next.from == from && (next.to > next.from || next.to == from)) {\n                    active.push(next);\n                    i++;\n                    to = Math.min(next.to, to);\n                }\n                else {\n                    to = Math.min(next.from, to);\n                    break;\n                }\n            }\n            let sev = maxSeverity(active);\n            if (active.some(d => d.from == d.to || (d.from == d.to - 1 && state.doc.lineAt(d.from).to == d.from))) {\n                deco.add(from, from, Decoration.widget({\n                    widget: new DiagnosticWidget(sev),\n                    diagnostics: active.slice()\n                }));\n            }\n            else {\n                let markClass = active.reduce((c, d) => d.markClass ? c + \" \" + d.markClass : c, \"\");\n                deco.add(from, to, Decoration.mark({\n                    class: \"cm-lintRange cm-lintRange-\" + sev + markClass,\n                    diagnostics: active.slice(),\n                    inclusiveEnd: active.some(a => a.to > to)\n                }));\n            }\n            pos = to;\n            for (let i = 0; i < active.length; i++)\n                if (active[i].to <= pos)\n                    active.splice(i--, 1);\n        }\n        let set = deco.finish();\n        return new LintState(set, panel, findDiagnostic(set));\n    }\n}\nfunction findDiagnostic(diagnostics, diagnostic = null, after = 0) {\n    let found = null;\n    diagnostics.between(after, 1e9, (from, to, { spec }) => {\n        if (diagnostic && spec.diagnostics.indexOf(diagnostic) < 0)\n            return;\n        if (!found)\n            found = new SelectedDiagnostic(from, to, diagnostic || spec.diagnostics[0]);\n        else if (spec.diagnostics.indexOf(found.diagnostic) < 0)\n            return false;\n        else\n            found = new SelectedDiagnostic(found.from, to, found.diagnostic);\n    });\n    return found;\n}\nfunction hideTooltip(tr, tooltip) {\n    let from = tooltip.pos, to = tooltip.end || from;\n    let result = tr.state.facet(lintConfig).hideOn(tr, from, to);\n    if (result != null)\n        return result;\n    let line = tr.startState.doc.lineAt(tooltip.pos);\n    return !!(tr.effects.some(e => e.is(setDiagnosticsEffect)) || tr.changes.touchesRange(line.from, Math.max(line.to, to)));\n}\nfunction maybeEnableLint(state, effects) {\n    return state.field(lintState, false) ? effects : effects.concat(StateEffect.appendConfig.of(lintExtensions));\n}\n/**\nReturns a transaction spec which updates the current set of\ndiagnostics, and enables the lint extension if if wasn't already\nactive.\n*/\nfunction setDiagnostics(state, diagnostics) {\n    return {\n        effects: maybeEnableLint(state, [setDiagnosticsEffect.of(diagnostics)])\n    };\n}\n/**\nThe state effect that updates the set of active diagnostics. Can\nbe useful when writing an extension that needs to track these.\n*/\nconst setDiagnosticsEffect = /*@__PURE__*/StateEffect.define();\nconst togglePanel = /*@__PURE__*/StateEffect.define();\nconst movePanelSelection = /*@__PURE__*/StateEffect.define();\nconst lintState = /*@__PURE__*/StateField.define({\n    create() {\n        return new LintState(Decoration.none, null, null);\n    },\n    update(value, tr) {\n        if (tr.docChanged && value.diagnostics.size) {\n            let mapped = value.diagnostics.map(tr.changes), selected = null, panel = value.panel;\n            if (value.selected) {\n                let selPos = tr.changes.mapPos(value.selected.from, 1);\n                selected = findDiagnostic(mapped, value.selected.diagnostic, selPos) || findDiagnostic(mapped, null, selPos);\n            }\n            if (!mapped.size && panel && tr.state.facet(lintConfig).autoPanel)\n                panel = null;\n            value = new LintState(mapped, panel, selected);\n        }\n        for (let effect of tr.effects) {\n            if (effect.is(setDiagnosticsEffect)) {\n                let panel = !tr.state.facet(lintConfig).autoPanel ? value.panel : effect.value.length ? LintPanel.open : null;\n                value = LintState.init(effect.value, panel, tr.state);\n            }\n            else if (effect.is(togglePanel)) {\n                value = new LintState(value.diagnostics, effect.value ? LintPanel.open : null, value.selected);\n            }\n            else if (effect.is(movePanelSelection)) {\n                value = new LintState(value.diagnostics, value.panel, effect.value);\n            }\n        }\n        return value;\n    },\n    provide: f => [showPanel.from(f, val => val.panel),\n        EditorView.decorations.from(f, s => s.diagnostics)]\n});\n/**\nReturns the number of active lint diagnostics in the given state.\n*/\nfunction diagnosticCount(state) {\n    let lint = state.field(lintState, false);\n    return lint ? lint.diagnostics.size : 0;\n}\nconst activeMark = /*@__PURE__*/Decoration.mark({ class: \"cm-lintRange cm-lintRange-active\" });\nfunction lintTooltip(view, pos, side) {\n    let { diagnostics } = view.state.field(lintState);\n    let found, start = -1, end = -1;\n    diagnostics.between(pos - (side < 0 ? 1 : 0), pos + (side > 0 ? 1 : 0), (from, to, { spec }) => {\n        if (pos >= from && pos <= to &&\n            (from == to || ((pos > from || side > 0) && (pos < to || side < 0)))) {\n            found = spec.diagnostics;\n            start = from;\n            end = to;\n            return false;\n        }\n    });\n    let diagnosticFilter = view.state.facet(lintConfig).tooltipFilter;\n    if (found && diagnosticFilter)\n        found = diagnosticFilter(found, view.state);\n    if (!found)\n        return null;\n    return {\n        pos: start,\n        end: end,\n        above: view.state.doc.lineAt(start).to < end,\n        create() {\n            return { dom: diagnosticsTooltip(view, found) };\n        }\n    };\n}\nfunction diagnosticsTooltip(view, diagnostics) {\n    return elt(\"ul\", { class: \"cm-tooltip-lint\" }, diagnostics.map(d => renderDiagnostic(view, d, false)));\n}\n/**\nCommand to open and focus the lint panel.\n*/\nconst openLintPanel = (view) => {\n    let field = view.state.field(lintState, false);\n    if (!field || !field.panel)\n        view.dispatch({ effects: maybeEnableLint(view.state, [togglePanel.of(true)]) });\n    let panel = getPanel(view, LintPanel.open);\n    if (panel)\n        panel.dom.querySelector(\".cm-panel-lint ul\").focus();\n    return true;\n};\n/**\nCommand to close the lint panel, when open.\n*/\nconst closeLintPanel = (view) => {\n    let field = view.state.field(lintState, false);\n    if (!field || !field.panel)\n        return false;\n    view.dispatch({ effects: togglePanel.of(false) });\n    return true;\n};\n/**\nMove the selection to the next diagnostic.\n*/\nconst nextDiagnostic = (view) => {\n    let field = view.state.field(lintState, false);\n    if (!field)\n        return false;\n    let sel = view.state.selection.main, next = field.diagnostics.iter(sel.to + 1);\n    if (!next.value) {\n        next = field.diagnostics.iter(0);\n        if (!next.value || next.from == sel.from && next.to == sel.to)\n            return false;\n    }\n    view.dispatch({ selection: { anchor: next.from, head: next.to }, scrollIntoView: true });\n    return true;\n};\n/**\nMove the selection to the previous diagnostic.\n*/\nconst previousDiagnostic = (view) => {\n    let { state } = view, field = state.field(lintState, false);\n    if (!field)\n        return false;\n    let sel = state.selection.main;\n    let prevFrom, prevTo, lastFrom, lastTo;\n    field.diagnostics.between(0, state.doc.length, (from, to) => {\n        if (to < sel.to && (prevFrom == null || prevFrom < from)) {\n            prevFrom = from;\n            prevTo = to;\n        }\n        if (lastFrom == null || from > lastFrom) {\n            lastFrom = from;\n            lastTo = to;\n        }\n    });\n    if (lastFrom == null || prevFrom == null && lastFrom == sel.from)\n        return false;\n    view.dispatch({ selection: { anchor: prevFrom !== null && prevFrom !== void 0 ? prevFrom : lastFrom, head: prevTo !== null && prevTo !== void 0 ? prevTo : lastTo }, scrollIntoView: true });\n    return true;\n};\n/**\nA set of default key bindings for the lint functionality.\n\n- Ctrl-Shift-m (Cmd-Shift-m on macOS): [`openLintPanel`](https://codemirror.net/6/docs/ref/#lint.openLintPanel)\n- F8: [`nextDiagnostic`](https://codemirror.net/6/docs/ref/#lint.nextDiagnostic)\n*/\nconst lintKeymap = [\n    { key: \"Mod-Shift-m\", run: openLintPanel, preventDefault: true },\n    { key: \"F8\", run: nextDiagnostic }\n];\nconst lintPlugin = /*@__PURE__*/ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.view = view;\n        this.timeout = -1;\n        this.set = true;\n        let { delay } = view.state.facet(lintConfig);\n        this.lintTime = Date.now() + delay;\n        this.run = this.run.bind(this);\n        this.timeout = setTimeout(this.run, delay);\n    }\n    run() {\n        clearTimeout(this.timeout);\n        let now = Date.now();\n        if (now < this.lintTime - 10) {\n            this.timeout = setTimeout(this.run, this.lintTime - now);\n        }\n        else {\n            this.set = false;\n            let { state } = this.view, { sources } = state.facet(lintConfig);\n            if (sources.length)\n                batchResults(sources.map(s => Promise.resolve(s(this.view))), annotations => {\n                    if (this.view.state.doc == state.doc)\n                        this.view.dispatch(setDiagnostics(this.view.state, annotations.reduce((a, b) => a.concat(b))));\n                }, error => { logException(this.view.state, error); });\n        }\n    }\n    update(update) {\n        let config = update.state.facet(lintConfig);\n        if (update.docChanged || config != update.startState.facet(lintConfig) ||\n            config.needsRefresh && config.needsRefresh(update)) {\n            this.lintTime = Date.now() + config.delay;\n            if (!this.set) {\n                this.set = true;\n                this.timeout = setTimeout(this.run, config.delay);\n            }\n        }\n    }\n    force() {\n        if (this.set) {\n            this.lintTime = Date.now();\n            this.run();\n        }\n    }\n    destroy() {\n        clearTimeout(this.timeout);\n    }\n});\nfunction batchResults(promises, sink, error) {\n    let collected = [], timeout = -1;\n    for (let p of promises)\n        p.then(value => {\n            collected.push(value);\n            clearTimeout(timeout);\n            if (collected.length == promises.length)\n                sink(collected);\n            else\n                timeout = setTimeout(() => sink(collected), 200);\n        }, error);\n}\nconst lintConfig = /*@__PURE__*/Facet.define({\n    combine(input) {\n        return Object.assign({ sources: input.map(i => i.source).filter(x => x != null) }, combineConfig(input.map(i => i.config), {\n            delay: 750,\n            markerFilter: null,\n            tooltipFilter: null,\n            needsRefresh: null,\n            hideOn: () => null,\n        }, {\n            needsRefresh: (a, b) => !a ? b : !b ? a : u => a(u) || b(u)\n        }));\n    }\n});\n/**\nGiven a diagnostic source, this function returns an extension that\nenables linting with that source. It will be called whenever the\neditor is idle (after its content changed). If `null` is given as\nsource, this only configures the lint extension.\n*/\nfunction linter(source, config = {}) {\n    return [\n        lintConfig.of({ source, config }),\n        lintPlugin,\n        lintExtensions\n    ];\n}\n/**\nForces any linters [configured](https://codemirror.net/6/docs/ref/#lint.linter) to run when the\neditor is idle to run right away.\n*/\nfunction forceLinting(view) {\n    let plugin = view.plugin(lintPlugin);\n    if (plugin)\n        plugin.force();\n}\nfunction assignKeys(actions) {\n    let assigned = [];\n    if (actions)\n        actions: for (let { name } of actions) {\n            for (let i = 0; i < name.length; i++) {\n                let ch = name[i];\n                if (/[a-zA-Z]/.test(ch) && !assigned.some(c => c.toLowerCase() == ch.toLowerCase())) {\n                    assigned.push(ch);\n                    continue actions;\n                }\n            }\n            assigned.push(\"\");\n        }\n    return assigned;\n}\nfunction renderDiagnostic(view, diagnostic, inPanel) {\n    var _a;\n    let keys = inPanel ? assignKeys(diagnostic.actions) : [];\n    return elt(\"li\", { class: \"cm-diagnostic cm-diagnostic-\" + diagnostic.severity }, elt(\"span\", { class: \"cm-diagnosticText\" }, diagnostic.renderMessage ? diagnostic.renderMessage(view) : diagnostic.message), (_a = diagnostic.actions) === null || _a === void 0 ? void 0 : _a.map((action, i) => {\n        let fired = false, click = (e) => {\n            e.preventDefault();\n            if (fired)\n                return;\n            fired = true;\n            let found = findDiagnostic(view.state.field(lintState).diagnostics, diagnostic);\n            if (found)\n                action.apply(view, found.from, found.to);\n        };\n        let { name } = action, keyIndex = keys[i] ? name.indexOf(keys[i]) : -1;\n        let nameElt = keyIndex < 0 ? name : [name.slice(0, keyIndex),\n            elt(\"u\", name.slice(keyIndex, keyIndex + 1)),\n            name.slice(keyIndex + 1)];\n        return elt(\"button\", {\n            type: \"button\",\n            class: \"cm-diagnosticAction\",\n            onclick: click,\n            onmousedown: click,\n            \"aria-label\": ` Action: ${name}${keyIndex < 0 ? \"\" : ` (access key \"${keys[i]})\"`}.`\n        }, nameElt);\n    }), diagnostic.source && elt(\"div\", { class: \"cm-diagnosticSource\" }, diagnostic.source));\n}\nclass DiagnosticWidget extends WidgetType {\n    constructor(sev) {\n        super();\n        this.sev = sev;\n    }\n    eq(other) { return other.sev == this.sev; }\n    toDOM() {\n        return elt(\"span\", { class: \"cm-lintPoint cm-lintPoint-\" + this.sev });\n    }\n}\nclass PanelItem {\n    constructor(view, diagnostic) {\n        this.diagnostic = diagnostic;\n        this.id = \"item_\" + Math.floor(Math.random() * 0xffffffff).toString(16);\n        this.dom = renderDiagnostic(view, diagnostic, true);\n        this.dom.id = this.id;\n        this.dom.setAttribute(\"role\", \"option\");\n    }\n}\nclass LintPanel {\n    constructor(view) {\n        this.view = view;\n        this.items = [];\n        let onkeydown = (event) => {\n            if (event.keyCode == 27) { // Escape\n                closeLintPanel(this.view);\n                this.view.focus();\n            }\n            else if (event.keyCode == 38 || event.keyCode == 33) { // ArrowUp, PageUp\n                this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);\n            }\n            else if (event.keyCode == 40 || event.keyCode == 34) { // ArrowDown, PageDown\n                this.moveSelection((this.selectedIndex + 1) % this.items.length);\n            }\n            else if (event.keyCode == 36) { // Home\n                this.moveSelection(0);\n            }\n            else if (event.keyCode == 35) { // End\n                this.moveSelection(this.items.length - 1);\n            }\n            else if (event.keyCode == 13) { // Enter\n                this.view.focus();\n            }\n            else if (event.keyCode >= 65 && event.keyCode <= 90 && this.selectedIndex >= 0) { // A-Z\n                let { diagnostic } = this.items[this.selectedIndex], keys = assignKeys(diagnostic.actions);\n                for (let i = 0; i < keys.length; i++)\n                    if (keys[i].toUpperCase().charCodeAt(0) == event.keyCode) {\n                        let found = findDiagnostic(this.view.state.field(lintState).diagnostics, diagnostic);\n                        if (found)\n                            diagnostic.actions[i].apply(view, found.from, found.to);\n                    }\n            }\n            else {\n                return;\n            }\n            event.preventDefault();\n        };\n        let onclick = (event) => {\n            for (let i = 0; i < this.items.length; i++) {\n                if (this.items[i].dom.contains(event.target))\n                    this.moveSelection(i);\n            }\n        };\n        this.list = elt(\"ul\", {\n            tabIndex: 0,\n            role: \"listbox\",\n            \"aria-label\": this.view.state.phrase(\"Diagnostics\"),\n            onkeydown,\n            onclick\n        });\n        this.dom = elt(\"div\", { class: \"cm-panel-lint\" }, this.list, elt(\"button\", {\n            type: \"button\",\n            name: \"close\",\n            \"aria-label\": this.view.state.phrase(\"close\"),\n            onclick: () => closeLintPanel(this.view)\n        }, \"×\"));\n        this.update();\n    }\n    get selectedIndex() {\n        let selected = this.view.state.field(lintState).selected;\n        if (!selected)\n            return -1;\n        for (let i = 0; i < this.items.length; i++)\n            if (this.items[i].diagnostic == selected.diagnostic)\n                return i;\n        return -1;\n    }\n    update() {\n        let { diagnostics, selected } = this.view.state.field(lintState);\n        let i = 0, needsSync = false, newSelectedItem = null;\n        let seen = new Set();\n        diagnostics.between(0, this.view.state.doc.length, (_start, _end, { spec }) => {\n            for (let diagnostic of spec.diagnostics) {\n                if (seen.has(diagnostic))\n                    continue;\n                seen.add(diagnostic);\n                let found = -1, item;\n                for (let j = i; j < this.items.length; j++)\n                    if (this.items[j].diagnostic == diagnostic) {\n                        found = j;\n                        break;\n                    }\n                if (found < 0) {\n                    item = new PanelItem(this.view, diagnostic);\n                    this.items.splice(i, 0, item);\n                    needsSync = true;\n                }\n                else {\n                    item = this.items[found];\n                    if (found > i) {\n                        this.items.splice(i, found - i);\n                        needsSync = true;\n                    }\n                }\n                if (selected && item.diagnostic == selected.diagnostic) {\n                    if (!item.dom.hasAttribute(\"aria-selected\")) {\n                        item.dom.setAttribute(\"aria-selected\", \"true\");\n                        newSelectedItem = item;\n                    }\n                }\n                else if (item.dom.hasAttribute(\"aria-selected\")) {\n                    item.dom.removeAttribute(\"aria-selected\");\n                }\n                i++;\n            }\n        });\n        while (i < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0)) {\n            needsSync = true;\n            this.items.pop();\n        }\n        if (this.items.length == 0) {\n            this.items.push(new PanelItem(this.view, {\n                from: -1, to: -1,\n                severity: \"info\",\n                message: this.view.state.phrase(\"No diagnostics\")\n            }));\n            needsSync = true;\n        }\n        if (newSelectedItem) {\n            this.list.setAttribute(\"aria-activedescendant\", newSelectedItem.id);\n            this.view.requestMeasure({\n                key: this,\n                read: () => ({ sel: newSelectedItem.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),\n                write: ({ sel, panel }) => {\n                    let scaleY = panel.height / this.list.offsetHeight;\n                    if (sel.top < panel.top)\n                        this.list.scrollTop -= (panel.top - sel.top) / scaleY;\n                    else if (sel.bottom > panel.bottom)\n                        this.list.scrollTop += (sel.bottom - panel.bottom) / scaleY;\n                }\n            });\n        }\n        else if (this.selectedIndex < 0) {\n            this.list.removeAttribute(\"aria-activedescendant\");\n        }\n        if (needsSync)\n            this.sync();\n    }\n    sync() {\n        let domPos = this.list.firstChild;\n        function rm() {\n            let prev = domPos;\n            domPos = prev.nextSibling;\n            prev.remove();\n        }\n        for (let item of this.items) {\n            if (item.dom.parentNode == this.list) {\n                while (domPos != item.dom)\n                    rm();\n                domPos = item.dom.nextSibling;\n            }\n            else {\n                this.list.insertBefore(item.dom, domPos);\n            }\n        }\n        while (domPos)\n            rm();\n    }\n    moveSelection(selectedIndex) {\n        if (this.selectedIndex < 0)\n            return;\n        let field = this.view.state.field(lintState);\n        let selection = findDiagnostic(field.diagnostics, this.items[selectedIndex].diagnostic);\n        if (!selection)\n            return;\n        this.view.dispatch({\n            selection: { anchor: selection.from, head: selection.to },\n            scrollIntoView: true,\n            effects: movePanelSelection.of(selection)\n        });\n    }\n    static open(view) { return new LintPanel(view); }\n}\nfunction svg(content, attrs = `viewBox=\"0 0 40 40\"`) {\n    return `url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" ${attrs}>${encodeURIComponent(content)}</svg>')`;\n}\nfunction underline(color) {\n    return svg(`<path d=\"m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0\" stroke=\"${color}\" fill=\"none\" stroke-width=\".7\"/>`, `width=\"6\" height=\"3\"`);\n}\nconst baseTheme = /*@__PURE__*/EditorView.baseTheme({\n    \".cm-diagnostic\": {\n        padding: \"3px 6px 3px 8px\",\n        marginLeft: \"-1px\",\n        display: \"block\",\n        whiteSpace: \"pre-wrap\"\n    },\n    \".cm-diagnostic-error\": { borderLeft: \"5px solid #d11\" },\n    \".cm-diagnostic-warning\": { borderLeft: \"5px solid orange\" },\n    \".cm-diagnostic-info\": { borderLeft: \"5px solid #999\" },\n    \".cm-diagnostic-hint\": { borderLeft: \"5px solid #66d\" },\n    \".cm-diagnosticAction\": {\n        font: \"inherit\",\n        border: \"none\",\n        padding: \"2px 4px\",\n        backgroundColor: \"#444\",\n        color: \"white\",\n        borderRadius: \"3px\",\n        marginLeft: \"8px\",\n        cursor: \"pointer\"\n    },\n    \".cm-diagnosticSource\": {\n        fontSize: \"70%\",\n        opacity: .7\n    },\n    \".cm-lintRange\": {\n        backgroundPosition: \"left bottom\",\n        backgroundRepeat: \"repeat-x\",\n        paddingBottom: \"0.7px\",\n    },\n    \".cm-lintRange-error\": { backgroundImage: /*@__PURE__*/underline(\"#d11\") },\n    \".cm-lintRange-warning\": { backgroundImage: /*@__PURE__*/underline(\"orange\") },\n    \".cm-lintRange-info\": { backgroundImage: /*@__PURE__*/underline(\"#999\") },\n    \".cm-lintRange-hint\": { backgroundImage: /*@__PURE__*/underline(\"#66d\") },\n    \".cm-lintRange-active\": { backgroundColor: \"#ffdd9980\" },\n    \".cm-tooltip-lint\": {\n        padding: 0,\n        margin: 0\n    },\n    \".cm-lintPoint\": {\n        position: \"relative\",\n        \"&:after\": {\n            content: '\"\"',\n            position: \"absolute\",\n            bottom: 0,\n            left: \"-2px\",\n            borderLeft: \"3px solid transparent\",\n            borderRight: \"3px solid transparent\",\n            borderBottom: \"4px solid #d11\"\n        }\n    },\n    \".cm-lintPoint-warning\": {\n        \"&:after\": { borderBottomColor: \"orange\" }\n    },\n    \".cm-lintPoint-info\": {\n        \"&:after\": { borderBottomColor: \"#999\" }\n    },\n    \".cm-lintPoint-hint\": {\n        \"&:after\": { borderBottomColor: \"#66d\" }\n    },\n    \".cm-panel.cm-panel-lint\": {\n        position: \"relative\",\n        \"& ul\": {\n            maxHeight: \"100px\",\n            overflowY: \"auto\",\n            \"& [aria-selected]\": {\n                backgroundColor: \"#ddd\",\n                \"& u\": { textDecoration: \"underline\" }\n            },\n            \"&:focus [aria-selected]\": {\n                background_fallback: \"#bdf\",\n                backgroundColor: \"Highlight\",\n                color_fallback: \"white\",\n                color: \"HighlightText\"\n            },\n            \"& u\": { textDecoration: \"none\" },\n            padding: 0,\n            margin: 0\n        },\n        \"& [name=close]\": {\n            position: \"absolute\",\n            top: \"0\",\n            right: \"2px\",\n            background: \"inherit\",\n            border: \"none\",\n            font: \"inherit\",\n            padding: 0,\n            margin: 0\n        }\n    }\n});\nfunction severityWeight(sev) {\n    return sev == \"error\" ? 4 : sev == \"warning\" ? 3 : sev == \"info\" ? 2 : 1;\n}\nfunction maxSeverity(diagnostics) {\n    let sev = \"hint\", weight = 1;\n    for (let d of diagnostics) {\n        let w = severityWeight(d.severity);\n        if (w > weight) {\n            weight = w;\n            sev = d.severity;\n        }\n    }\n    return sev;\n}\nclass LintGutterMarker extends GutterMarker {\n    constructor(diagnostics) {\n        super();\n        this.diagnostics = diagnostics;\n        this.severity = maxSeverity(diagnostics);\n    }\n    toDOM(view) {\n        let elt = document.createElement(\"div\");\n        elt.className = \"cm-lint-marker cm-lint-marker-\" + this.severity;\n        let diagnostics = this.diagnostics;\n        let diagnosticsFilter = view.state.facet(lintGutterConfig).tooltipFilter;\n        if (diagnosticsFilter)\n            diagnostics = diagnosticsFilter(diagnostics, view.state);\n        if (diagnostics.length)\n            elt.onmouseover = () => gutterMarkerMouseOver(view, elt, diagnostics);\n        return elt;\n    }\n}\nfunction trackHoverOn(view, marker) {\n    let mousemove = (event) => {\n        let rect = marker.getBoundingClientRect();\n        if (event.clientX > rect.left - 10 /* Hover.Margin */ && event.clientX < rect.right + 10 /* Hover.Margin */ &&\n            event.clientY > rect.top - 10 /* Hover.Margin */ && event.clientY < rect.bottom + 10 /* Hover.Margin */)\n            return;\n        for (let target = event.target; target; target = target.parentNode) {\n            if (target.nodeType == 1 && target.classList.contains(\"cm-tooltip-lint\"))\n                return;\n        }\n        window.removeEventListener(\"mousemove\", mousemove);\n        if (view.state.field(lintGutterTooltip))\n            view.dispatch({ effects: setLintGutterTooltip.of(null) });\n    };\n    window.addEventListener(\"mousemove\", mousemove);\n}\nfunction gutterMarkerMouseOver(view, marker, diagnostics) {\n    function hovered() {\n        let line = view.elementAtHeight(marker.getBoundingClientRect().top + 5 - view.documentTop);\n        const linePos = view.coordsAtPos(line.from);\n        if (linePos) {\n            view.dispatch({ effects: setLintGutterTooltip.of({\n                    pos: line.from,\n                    above: false,\n                    clip: false,\n                    create() {\n                        return {\n                            dom: diagnosticsTooltip(view, diagnostics),\n                            getCoords: () => marker.getBoundingClientRect()\n                        };\n                    }\n                }) });\n        }\n        marker.onmouseout = marker.onmousemove = null;\n        trackHoverOn(view, marker);\n    }\n    let { hoverTime } = view.state.facet(lintGutterConfig);\n    let hoverTimeout = setTimeout(hovered, hoverTime);\n    marker.onmouseout = () => {\n        clearTimeout(hoverTimeout);\n        marker.onmouseout = marker.onmousemove = null;\n    };\n    marker.onmousemove = () => {\n        clearTimeout(hoverTimeout);\n        hoverTimeout = setTimeout(hovered, hoverTime);\n    };\n}\nfunction markersForDiagnostics(doc, diagnostics) {\n    let byLine = Object.create(null);\n    for (let diagnostic of diagnostics) {\n        let line = doc.lineAt(diagnostic.from);\n        (byLine[line.from] || (byLine[line.from] = [])).push(diagnostic);\n    }\n    let markers = [];\n    for (let line in byLine) {\n        markers.push(new LintGutterMarker(byLine[line]).range(+line));\n    }\n    return RangeSet.of(markers, true);\n}\nconst lintGutterExtension = /*@__PURE__*/gutter({\n    class: \"cm-gutter-lint\",\n    markers: view => view.state.field(lintGutterMarkers),\n    widgetMarker: (view, widget, block) => {\n        let diagnostics = [];\n        view.state.field(lintGutterMarkers).between(block.from, block.to, (from, to, value) => {\n            if (from > block.from && from < block.to)\n                diagnostics.push(...value.diagnostics);\n        });\n        return diagnostics.length ? new LintGutterMarker(diagnostics) : null;\n    }\n});\nconst lintGutterMarkers = /*@__PURE__*/StateField.define({\n    create() {\n        return RangeSet.empty;\n    },\n    update(markers, tr) {\n        markers = markers.map(tr.changes);\n        let diagnosticFilter = tr.state.facet(lintGutterConfig).markerFilter;\n        for (let effect of tr.effects) {\n            if (effect.is(setDiagnosticsEffect)) {\n                let diagnostics = effect.value;\n                if (diagnosticFilter)\n                    diagnostics = diagnosticFilter(diagnostics || [], tr.state);\n                markers = markersForDiagnostics(tr.state.doc, diagnostics.slice(0));\n            }\n        }\n        return markers;\n    }\n});\nconst setLintGutterTooltip = /*@__PURE__*/StateEffect.define();\nconst lintGutterTooltip = /*@__PURE__*/StateField.define({\n    create() { return null; },\n    update(tooltip, tr) {\n        if (tooltip && tr.docChanged)\n            tooltip = hideTooltip(tr, tooltip) ? null : Object.assign(Object.assign({}, tooltip), { pos: tr.changes.mapPos(tooltip.pos) });\n        return tr.effects.reduce((t, e) => e.is(setLintGutterTooltip) ? e.value : t, tooltip);\n    },\n    provide: field => showTooltip.from(field)\n});\nconst lintGutterTheme = /*@__PURE__*/EditorView.baseTheme({\n    \".cm-gutter-lint\": {\n        width: \"1.4em\",\n        \"& .cm-gutterElement\": {\n            padding: \".2em\"\n        }\n    },\n    \".cm-lint-marker\": {\n        width: \"1em\",\n        height: \"1em\"\n    },\n    \".cm-lint-marker-info\": {\n        content: /*@__PURE__*/svg(`<path fill=\"#aaf\" stroke=\"#77e\" stroke-width=\"6\" stroke-linejoin=\"round\" d=\"M5 5L35 5L35 35L5 35Z\"/>`)\n    },\n    \".cm-lint-marker-warning\": {\n        content: /*@__PURE__*/svg(`<path fill=\"#fe8\" stroke=\"#fd7\" stroke-width=\"6\" stroke-linejoin=\"round\" d=\"M20 6L37 35L3 35Z\"/>`),\n    },\n    \".cm-lint-marker-error\": {\n        content: /*@__PURE__*/svg(`<circle cx=\"20\" cy=\"20\" r=\"15\" fill=\"#f87\" stroke=\"#f43\" stroke-width=\"6\"/>`)\n    },\n});\nconst lintExtensions = [\n    lintState,\n    /*@__PURE__*/EditorView.decorations.compute([lintState], state => {\n        let { selected, panel } = state.field(lintState);\n        return !selected || !panel || selected.from == selected.to ? Decoration.none : Decoration.set([\n            activeMark.range(selected.from, selected.to)\n        ]);\n    }),\n    /*@__PURE__*/hoverTooltip(lintTooltip, { hideOn: hideTooltip }),\n    baseTheme\n];\nconst lintGutterConfig = /*@__PURE__*/Facet.define({\n    combine(configs) {\n        return combineConfig(configs, {\n            hoverTime: 300 /* Hover.Time */,\n            markerFilter: null,\n            tooltipFilter: null\n        });\n    }\n});\n/**\nReturns an extension that installs a gutter showing markers for\neach line that has diagnostics, which can be hovered over to see\nthe diagnostics.\n*/\nfunction lintGutter(config = {}) {\n    return [lintGutterConfig.of(config), lintGutterMarkers, lintGutterExtension, lintGutterTheme, lintGutterTooltip];\n}\n/**\nIterate over the marked diagnostics for the given editor state,\ncalling `f` for each of them. Note that, if the document changed\nsince the diagnostics were created, the `Diagnostic` object will\nhold the original outdated position, whereas the `to` and `from`\narguments hold the diagnostic's current position.\n*/\nfunction forEachDiagnostic(state, f) {\n    let lState = state.field(lintState, false);\n    if (lState && lState.diagnostics.size) {\n        let pending = [], pendingStart = [], lastEnd = -1;\n        for (let iter = RangeSet.iter([lState.diagnostics]);; iter.next()) {\n            for (let i = 0; i < pending.length; i++)\n                if (!iter.value || iter.value.spec.diagnostics.indexOf(pending[i]) < 0) {\n                    f(pending[i], pendingStart[i], lastEnd);\n                    pending.splice(i, 1);\n                    pendingStart.splice(i--, 1);\n                }\n            if (!iter.value)\n                break;\n            for (let d of iter.value.spec.diagnostics)\n                if (pending.indexOf(d) < 0) {\n                    pending.push(d);\n                    pendingStart.push(iter.from);\n                }\n            lastEnd = iter.to;\n        }\n    }\n}\n\nexport { closeLintPanel, diagnosticCount, forEachDiagnostic, forceLinting, lintGutter, lintKeymap, linter, nextDiagnostic, openLintPanel, previousDiagnostic, setDiagnostics, setDiagnosticsEffect };\n","import { lineNumbers, highlightActiveLineGutter, highlightSpecialChars, drawSelection, dropCursor, rectangularSelection, crosshairCursor, highlightActiveLine, keymap } from '@codemirror/view';\nexport { EditorView } from '@codemirror/view';\nimport { EditorState } from '@codemirror/state';\nimport { foldGutter, indentOnInput, syntaxHighlighting, defaultHighlightStyle, bracketMatching, foldKeymap } from '@codemirror/language';\nimport { history, defaultKeymap, historyKeymap } from '@codemirror/commands';\nimport { highlightSelectionMatches, searchKeymap } from '@codemirror/search';\nimport { closeBrackets, autocompletion, closeBracketsKeymap, completionKeymap } from '@codemirror/autocomplete';\nimport { lintKeymap } from '@codemirror/lint';\n\n// (The superfluous function calls around the list of extensions work\n// around current limitations in tree-shaking software.)\n/**\nThis is an extension value that just pulls together a number of\nextensions that you might want in a basic editor. It is meant as a\nconvenient helper to quickly set up CodeMirror without installing\nand importing a lot of separate packages.\n\nSpecifically, it includes...\n\n - [the default command bindings](https://codemirror.net/6/docs/ref/#commands.defaultKeymap)\n - [line numbers](https://codemirror.net/6/docs/ref/#view.lineNumbers)\n - [special character highlighting](https://codemirror.net/6/docs/ref/#view.highlightSpecialChars)\n - [the undo history](https://codemirror.net/6/docs/ref/#commands.history)\n - [a fold gutter](https://codemirror.net/6/docs/ref/#language.foldGutter)\n - [custom selection drawing](https://codemirror.net/6/docs/ref/#view.drawSelection)\n - [drop cursor](https://codemirror.net/6/docs/ref/#view.dropCursor)\n - [multiple selections](https://codemirror.net/6/docs/ref/#state.EditorState^allowMultipleSelections)\n - [reindentation on input](https://codemirror.net/6/docs/ref/#language.indentOnInput)\n - [the default highlight style](https://codemirror.net/6/docs/ref/#language.defaultHighlightStyle) (as fallback)\n - [bracket matching](https://codemirror.net/6/docs/ref/#language.bracketMatching)\n - [bracket closing](https://codemirror.net/6/docs/ref/#autocomplete.closeBrackets)\n - [autocompletion](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion)\n - [rectangular selection](https://codemirror.net/6/docs/ref/#view.rectangularSelection) and [crosshair cursor](https://codemirror.net/6/docs/ref/#view.crosshairCursor)\n - [active line highlighting](https://codemirror.net/6/docs/ref/#view.highlightActiveLine)\n - [active line gutter highlighting](https://codemirror.net/6/docs/ref/#view.highlightActiveLineGutter)\n - [selection match highlighting](https://codemirror.net/6/docs/ref/#search.highlightSelectionMatches)\n - [search](https://codemirror.net/6/docs/ref/#search.searchKeymap)\n - [linting](https://codemirror.net/6/docs/ref/#lint.lintKeymap)\n\n(You'll probably want to add some language package to your setup\ntoo.)\n\nThis extension does not allow customization. The idea is that,\nonce you decide you want to configure your editor more precisely,\nyou take this package's source (which is just a bunch of imports\nand an array literal), copy it into your own code, and adjust it\nas desired.\n*/\nconst basicSetup = /*@__PURE__*/(() => [\n    lineNumbers(),\n    highlightActiveLineGutter(),\n    highlightSpecialChars(),\n    history(),\n    foldGutter(),\n    drawSelection(),\n    dropCursor(),\n    EditorState.allowMultipleSelections.of(true),\n    indentOnInput(),\n    syntaxHighlighting(defaultHighlightStyle, { fallback: true }),\n    bracketMatching(),\n    closeBrackets(),\n    autocompletion(),\n    rectangularSelection(),\n    crosshairCursor(),\n    highlightActiveLine(),\n    highlightSelectionMatches(),\n    keymap.of([\n        ...closeBracketsKeymap,\n        ...defaultKeymap,\n        ...searchKeymap,\n        ...historyKeymap,\n        ...foldKeymap,\n        ...completionKeymap,\n        ...lintKeymap\n    ])\n])();\n/**\nA minimal set of extensions to create a functional editor. Only\nincludes [the default keymap](https://codemirror.net/6/docs/ref/#commands.defaultKeymap), [undo\nhistory](https://codemirror.net/6/docs/ref/#commands.history), [special character\nhighlighting](https://codemirror.net/6/docs/ref/#view.highlightSpecialChars), [custom selection\ndrawing](https://codemirror.net/6/docs/ref/#view.drawSelection), and [default highlight\nstyle](https://codemirror.net/6/docs/ref/#language.defaultHighlightStyle).\n*/\nconst minimalSetup = /*@__PURE__*/(() => [\n    highlightSpecialChars(),\n    history(),\n    drawSelection(),\n    syntaxHighlighting(defaultHighlightStyle, { fallback: true }),\n    keymap.of([\n        ...defaultKeymap,\n        ...historyKeymap,\n    ])\n])();\n\nexport { basicSetup, minimalSetup };\n"],"names":["crelt","elt","arguments","document","createElement","i","next","nodeType","Array","isArray","name","Object","prototype","hasOwnProperty","call","value","setAttribute","length","add","child","appendChild","createTextNode","RangeError","basicNormalize","String","normalize","x","SearchCursor","constructor","text","query","from","to","test","this","done","matches","buffer","bufferPos","iter","iterRange","bufferStart","peek","codePointAt","pop","nextOverlapping","str","fromCodePoint","start","codePointSize","norm","pos","code","charCodeAt","match","end","index","keep","splice","push","Symbol","iterator","empty","exec","baseFlags","unicode","RegExpCursor","options","curLine","MultilineRegExpCursor","re","RegExp","ignoreCase","startLine","lineAt","curLineStart","matchPos","toCharEnd","getLine","skip","lineBreak","slice","nextLine","off","lastIndex","flattened","WeakMap","FlattenedDoc","get","doc","cached","flat","sliceString","set","cachedFrom","chunkEnd","line","createLineDialog","view","input","class","state","selection","main","head","number","go","sign","ln","cl","percent","col","pc","lines","Math","round","docLine","max","min","EditorSelection","cursor","dispatch","effects","dialogEffect","of","EditorView","scrollIntoView","y","focus","dom","onkeydown","event","keyCode","preventDefault","onsubmit","phrase","type","onclick","StateEffect","define","dialogField","StateField","create","update","tr","e","is","provide","f","showPanel","val","baseTheme$1","baseTheme","padding","position","fontSize","top","bottom","right","backgroundColor","border","font","defaultHighlightOptions","highlightWordAroundCursor","minSelectionLength","maxMatches","wholeWords","highlightConfig","Facet","combine","combineConfig","a","b","matchDeco","Decoration","mark","mainMatchDeco","insideWordBoundaries","check","sliceDoc","CharCategory","Word","matchHighlighter","ViewPlugin","fromClass","decorations","getDeco","selectionSet","docChanged","viewportChanged","conf","facet","sel","ranges","none","range","word","wordAt","charCategorizer","len","insideWord","deco","part","visibleRanges","v","defaultTheme","searchConfigFacet","configs","caseSensitive","literal","regexp","wholeWord","createPanel","SearchPanel","scrollToMatch","SearchQuery","config","search","replace","valid","source","_a","validRegExp","unquoted","unquote","_","ch","eq","other","RegExpQuery","StringQuery","getCursor","st","EditorState","regexpCursor","stringCursor","QueryType","spec","undefined","toLowerCase","categorizer","buf","bufPos","charBefore","charAfter","super","nextMatch","curFrom","curTo","prevMatchInRange","prevMatch","found","getReplacement","_result","matchAll","limit","highlight","_from","_to","findClusterBreak","size","result","m","l","n","setSearchQuery","togglePanel","searchState","SearchState","defaultQuery","effect","panel","createSearchPanel","matchMark","selectedMatchMark","searchHighlighter","field","startState","builder","RangeSetBuilder","selected","some","r","finish","searchCommand","openSearchPanel","findNext","single","announceMatch","userEvent","selectSearchInput","findPrevious","prev","selectMatches","map","replaceNext","readOnly","replacement","changes","toText","insert","announce","replaceAll","announceText","fallback","_b","_c","_d","_e","selText","getSearchInput","getPanel","querySelector","root","activeElement","select","searchInput","appendConfig","searchExtensions","closeSearchPanel","contains","searchKeymap","key","run","scope","shift","cur","newSel","mainIndex","selectWord","searchedText","fullWord","cycled","findNextOccurrence","addRange","button","content","commit","bind","searchField","placeholder","form","onchange","onkeyup","replaceField","caseField","checked","reField","wordField","keydown","runScopeHandlers","target","shiftKey","transactions","setQuery","mount","AnnounceMargin","Break","lineEnd","margin","marginRight","whiteSpace","Prec","low","SelectedDiagnostic","diagnostic","LintState","diagnostics","init","diagnosticFilter","lintConfig","markerFilter","sorted","sort","active","reduce","p","d","sev","maxSeverity","widget","DiagnosticWidget","markClass","c","inclusiveEnd","findDiagnostic","after","between","indexOf","setDiagnosticsEffect","movePanelSelection","lintState","mapped","selPos","mapPos","autoPanel","LintPanel","open","s","activeMark","lintTooltip","side","tooltipFilter","above","diagnosticsTooltip","renderDiagnostic","closeLintPanel","lintKeymap","concat","lintExtensions","anchor","assign","sources","filter","delay","needsRefresh","hideOn","u","assignKeys","actions","assigned","inPanel","keys","severity","renderMessage","message","action","fired","click","apply","keyIndex","nameElt","onmousedown","WidgetType","toDOM","PanelItem","id","floor","random","toString","items","list","tabIndex","role","moveSelection","selectedIndex","toUpperCase","needsSync","newSelectedItem","seen","Set","_start","_end","has","item","j","hasAttribute","removeAttribute","requestMeasure","read","getBoundingClientRect","write","scaleY","height","offsetHeight","scrollTop","sync","domPos","firstChild","rm","nextSibling","remove","parentNode","insertBefore","underline","color","attrs","encodeURIComponent","svg","marginLeft","display","borderLeft","borderRadius","opacity","backgroundPosition","backgroundRepeat","paddingBottom","backgroundImage","left","borderRight","borderBottom","borderBottomColor","maxHeight","overflowY","textDecoration","background_fallback","color_fallback","background","severityWeight","weight","w","compute","hoverTooltip","tooltip","touchesRange","basicSetup","lineNumbers","highlightActiveLineGutter","highlightSpecialChars","history","foldGutter","drawSelection","dropCursor","allowMultipleSelections","indentOnInput","syntaxHighlighting","defaultHighlightStyle","bracketMatching","closeBrackets","autocompletion","rectangularSelection","crosshairCursor","highlightActiveLine","keymap","closeBracketsKeymap","defaultKeymap","historyKeymap","foldKeymap","completionKeymap","minimalSetup"],"mappings":"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","x_google_ignoreList":[0,1,2,3]}